移動が必要だから4x4行列である必要がある？っぽい。3x3行列では移動が行えない。たぶんそんな感じ。

* 点の変換では、第四成分を1に設定したベクトルを使用する
* それに対して方向の変換では、第四成分を0に設定したベクトルを使用する
* もしくは4x4行列を3x3行列に縮小する
* 法線ベクトルの変換でも第四成分が0のベクトルを使用するが、変換方法が異なるらしい
* 4x4行列の4行目を変更する可能性があるのは`.perspective()`のみ

昨日Discordで質問したのだけど、ようやくその答えが見つかった。とりあえず、Discordでの報告の前に、今の理解を気ままにここに書いていこうと思う。

答えは既に知っている。以下のコードは、プロジェクション変換を正しく行うためだけに用意されたコードだ。

```javascript
let w = m[3] * x + m[7] * y + m[11] * z + m[15];
w = w || 1.0;
```

なんでもプロジェクション変換だけ他の変換と本質的に異なる部分があって、それは変換行列自体が変換対象の点の z 座標を必要とするところ。

比べる対象となる他の変換について理解する必要があるので説明すると、回転行列を作るために必要な情報は「回転軸」と「角度」だけ。拡大縮小行列を作るために必要な情報は「どれくらい拡大縮小するか」だけ。けど、プロジェクション変換行列には「視野角」や「アスペクト比」の他に「変換対象の点の z 座標」が必要。これはつまり、事前に変換行列が作れないことを意味する（変換対象の点の z 座標が与えられて初めて行列が完成する）。

GPU は事前に用意された行列でしか演算できない。しかしプロジェクション変換には z 座標が必要。この相反する2つの課題を、先人はひとつのルールを設けることで解決した。そのルールというのは「GPU は行列演算後の4次元ベクトルを第四成分で割る」である。

さっきは「プロジェクション変換には点の z 座標が必要」と書いた。具体的に z 座標をどのように使うかというと、点の正しい x と y を求める際に使用する。その求め方というのが「x と y をそれぞれ z で割る」という操作である。

この操作と先ほどのルールを合わせると、プロジェクション変換の際に使う行列に「z を第四成分の位置に移動させる操作」を持たせればいいことになる。以下のコードの `w` には、プロジェクション変換が行われない場合には `1.0` が、行われる場合には z が（厳密には -z が）入る。

```javascript
let w = m[3] * x + m[7] * y + m[11] * z + m[15];
w = w || 1.0;
```

そうして作られた `w` で、その後 x と y を割っている（z も割ってしまっているが、その前に「z を掛ける」みたいな操作を行っているので問題ない）。

```javascript
out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
return out;
```

結論としては、「なぜこのようにして第四成分を求めているか」の答えは「GPU でそのようなルールが設けられているから。glMatrix は GPU の動きを再現している」である。

昨日の日記に、ベクトルを使えばトーラスを簡単に実装できると書いた。今日は8分の1球体をベクトルを使って書いたんだけど、あまりにも簡単に書けたので驚いた。上が書き換え前のコードで、下が書き換え後のコード。

```javascript
for (let i = 0; i <= c; i++) {
  const langle = Math.PI / 180 * 90 / c * i;
  const rad = r * Math.sin(langle);
  const y = r * Math.cos(langle);
  for (let j = 0; j <= c; j++) {
    const sangle = Math.PI / 180 * 90 / c * j;
    const x = rad * Math.cos(sangle);
    const z = rad * Math.sin(sangle);
    data.push({ position: V3(x, y, z), color });
  }
}
```

```javascript
for (let i = 0; i <= c; i++) {
  const v = V3(r, 0, 0).rotate(V3(0, 0, 1), 90 / c * i);
  for (let j = 0; j <= c; j++) {
    const p = v.rotate(V3(0, 1, 0), -90 / c * j);
    data.push({ position: p, color });
  }
}
```

意味的にも理解しやすい。「ベクトル `(r, 0, 0)` を、z 軸を軸として何度か回転させ、それをまた y 軸を軸として何度か回転させる」とすんなり読める。

円を扱うときはベクトルの回転をうまく使うとよいことがわかった。この調子で他のコードも書き換えていく。
