友達と Discord のサーバを建てた。  
名前とアイコン、活動内容などはまだ考え中。  
何か面白い変化があるといいな。

C++ パーサで詰まった部分がある。  
それは、演算子の優先順位と結合順序をどうするかという問題。  
具体的には、`1 + 2 + 3` という入力を与えたときは `((1 + 2) + 3)` と解析してほしいけど、  
`1 + 2 * 3` という入力を与えたときは `(1 + (2 * 3))` と解析してほしい。

* `1 + 2 + 3` : `((1 + 2) + 3)`
* `1 + 2 * 3` : `(1 + (2 * 3))`

解決策が思いついた。  
トップレベルに近いパーサは `+-` を読み込むパーサとし、  
トップレベルから遠いパーサは `*/` を読み込むパーサとする。
前者を `p_add_sub` として後者を `p_mul_div` とすると次のようになる。  
（`try` などは一旦考えない）

```haskell
p_add_sub = do
  lft <- p_mul_div
  op  <- oneOf "+-"
  rgt <- p_mul_div
  return (lft, op, rgt)

p_mul_div = do
  lft <- primitive
  op  <- oneOf "*/"
  rgt <- primitive
  return (lft, op, rgt)
```

こうすることで、`1 + 2 * 3` を与えたときは次の流れになる。  
と思って流れを書いていると間違いに気付いた。  
これでは不十分だ。  
`p_add_sub` はリスト的な何かを返さなければならない。  
それか木構造か。  
木構造のほうが難しそうだから、まずはリストを作ることにしよう。  
型はどんなふうにしようかな。  
`(Expression, [(String, Expression)]` にしよう。  
これであれば、`many` の戻り値をそのまま使うことができるから簡単だ。

ということで次のように書くことにした。

```haskell
p_add_sub_operator :: Parser String
p_add_sub_operator = string "+" <|> string "-"

p_mul_div_operator :: Parser String
p_mul_div_operator = string "*" <|> string "/"

p_add_sub :: Parser (Expression, [(String, Expression)])
p_add_sub = do
  lft <- p_mul_div
  rgt <- many $ p_add_sub_operator <*> p_mul_div
  return (lft, rgt)

p_mul_div :: Parser (Expression, [(String, Expression)])
p_mul_div = do
  lft <- p_primitive
  rgt <- many $ p_mul_div_operator <*> p_primitive
  return (lft, rgt)
```

ここで更にひとつ考えていなかったことがあった。  
`(Expression, [(String, Expression)])` というのもまた `Expresion` であるということだ。  
ということで、これを `data Expression` に追加して下記のように修正する。

```haskell
data Expression =
  ... |
  ExList (Expression, [(String, Expression)])
  deriving Show

...

p_add_sub :: Parser Expression
p_add_sub = do
  lft <- p_mul_div
  rgt <- many $ p_add_sub_operator <*> p_mul_div
  return . ExList $ (lft, rgt)

p_mul_div :: Parser Expression
p_mul_div = do
  lft <- p_primitive
  rgt <- many $ p_mul_div_operator <*> p_primitive
  return . ExList $ (lft, rgt)
```

これで完成だ（と思う）。  
具体的にシミュレーションしてみる。  

`1 + 2 * 3` という入力を与える。  
ここでは思考の単純化のために空白文字は考えない。  

`p_add_sub` のひとつめのパーサは `p_mul_div` なのでこのパーサに処理を託す。  
`p_mul_div` は `1` だけを読み取れ、それ以降の文字は読み取れない。  
なぜなら次の文字は `+` であり、これは `p_mul_div_operator` では読み取れないからだ。  
したがって、`p_mul_div` は `(1, [])` というパーサ結果をモナドに包んで返す。  
そしてこれの中身が呼び出し元の `p_add_sub` の `lft` に格納される。  

次に `p_add_sub_operator <*> p_mul_div` に一致するかどうかを判定する。  
次の文字は `+` であるため `p_add_sub_operator` によりこれを消費し、  
`2 * 3` が `p_mul_div` に渡される。  

`p_mul_div` のひとつ目のパーサである `p_primitive` は、`2` を読み取って `lft` に格納する。  
ふたつ目のパーサである `p_mul_div_operator <*> p_primitive` だが、  
これは成功する。なぜなら `* 3` の `*` は `p_mul_div_operator` が読み取り、  
`3` は `p_primitive` が読み取るからだ。  
こうして `p_mul_div_operator <*> p_primitive` は `("*", 3)` という結果になるため、  
これをリストにして `rgt` に格納する。  
`lft = 2` で `rgt = [("*", 3)]` だから、返される値は `ExList (2, [("*", 3)])` となる。  
これがモナドに包まれて呼び出し元に返される。

以上のような工程により、`p_add_sub_operator <*> p_mul_div` の  
結果は `ExList (2, [("*", 3)])` のようになる。  
これが `rgt` に格納されるため、  
最終的に作られる値は `ExList (1, ("+", [ExList (2, [("*", 3)]]))` となる。

できた。それでは実装していく。

実装を終えた。  
Hspec でスペックを書きながら開発していくのは最高だ。  
システムを拡張していくことに抵抗がなくなる。  

しかし、そろそろ `LibSpec.hs` が肥大化してきたので、Expression 系でまとめたいと思う。  
どういった手順を踏もう。  
まず `Expression.hs` と `ExpressionSpec.hs` を作成する。  
次に式に関するテストを `ExpressionSpec.hs` に移動させてテストを実行する。  
すると沢山のテストの失敗があると思うから、それを緑にするために関数や `data` を移行していく。  
それでいこう。  

最悪のケースを想定しよう。  
行動する前は最悪のケースを想定するという習慣をつけよう。  
今回の場合、最悪のケースはテストが一向に赤のままというケースだ。  
Haskell のモジュールシステムが実は貧弱で、同ディレクトリ内のモジュールを参照できず、  
わざわざライブラリをひとつずつコンパイルしないといけないとなったら最悪だ。  
しかしそれはおそらく起こらない。  
ということで、同ディレクトリ内のファイルは読み込めるから、  
移動させた関数を参照していたとしても、ただモジュールを読み込めばいいことになる。  
このときに、双方向に依存関係があると把握できなくなるので、  
依存方向は一方向にしよう。今回の場合は、`Lib.hs` は `Expression.hs` に依存するが、  
`Expression.hs` は `Lib.hs` に依存しないことにする。  

これ以上は考えることはなさそう。  
最悪のケースといっても特に何もなかった。  
それでは行動に移す。

できた。コミットしよう。

演算子の優先順位を実装できたことは大きい。  
これはつまり、他の様々な演算子についても同様に実装できるということだ。  
C++ の演算子の優先順位の表があるはずだから、調べてここに貼り付けよう。

思ったよりも多かったのでリンクだけ貼っておく。

[C++の演算子の優先順位 | cppreference.com](https://ja.cppreference.com/w/cpp/language/operator_precedence)

けっこう多くて大変なので、まずは簡単な剰余あたりから実装していく。  
その次はビットシフト、次は三方比較演算子…というように、徐々に優先順位を上げて実装していく。  
優先順位 1 ～ 4 については、見るからに大変そうなので後回しにする。  
それと、パーサの名前を `p_add_sub` から `p_priority_6` にする。  
そちらのほうがコードを書くときにわかりやすい。  
`p_priority_6` は `p_priority_5` は参照可能だが `p_priority_7` は参照不可といったように。  
優先順位の高い（数値の小さい）ものだけを参照可能とする。  

思ったけど、これから行うことはほとんど頭を使わない作業だ。  
スペックを書いて、テストの失敗を確認し、コードを書いてテストをパスする。  

特に最悪のケースとかはないので、こまめにコミットしながら進めていく。

コードの重複が気になり始めたから取り除くことにする。  
ほとんど頭を使わない作業と言ったけど、こうやって面白い課題が突然出てくるのが面白い。

* OK : `p_priority_9 = p_binops ["<=", ">=", "<", ">"] p_priority_8`
* NG : `p_priority_9 = p_binops ["<", ">", "<=", ">="] p_priority_8`

こうなってしまう原因がよくわからない。`try` を色んな所に入れてみたけど直らない。  

小まめにと言ったけど、優先順位 5 ～ 15 まで一気にやってしまった。

```haskell
describe "binary operator" $ do
  it "accept all binary operators" $ do
    foldl' (\a b -> spec_binop b) (return ()) $ concat [
      ["*", "/", "%"],
      ["+", "-"],
      ["<<", ">>"],
      ["<=>"],
      ["<=", ">=", "<", ">"],
      ["==", "!="],
      ["&"], ["^"], ["|"], ["&&"], ["||"],
      ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", "&=", "^=", "|="]]
```

上の `foldl' ...` は評価されない。しかし下の `spec_binop` は評価される。

```haskell
describe "binary operator" $ do
  it "accept all binary operators" $ do
    spec_binop "*"
```

この違いがよく分からない。

次のようなコードを書いた。

```haskell
p_priority_15 =
  foldl (&) p_primitive $
    map p_binops [
      ["*", "/", "%"],
      ["+", "-"],
      ["<<", ">>"],
      ["<=>"],
      ["<=", ">=", "<", ">"],
      ["==", "!="],
      ["&"], ["^"], ["|"], ["&&"], ["||"]]
```

この中で使われている `&` がすぐに理解できる人はたぶん存在しない。僕も2日後には忘れていると思う。  
絶対 `\a b -> b a` と直接書いたほうがいい。  
けど書いちゃう。一文字で済むのがかっこいいから書いちゃう。  

「この違いがよく分からない」と書いた先ほどのコード、原因が少しわかった。  

```haskell
-- OK
describe "binary operator" $ do
  it "accept all binary operators" $ do
    foldl' (\a b -> spec_binop b) (return ()) ["*", "a"]

-- NG
describe "binary operator" $ do
  it "accept all binary operators" $ do
    foldl' (\a b -> spec_binop b) (return ()) ["a", "*"]
```

つまり最後の要素以外は無視されるということ。  
そして無視される原因は、`\a b -> spec_binop b` というように `a` を使っていないから。  
僕は `spec_binop` の副作用が目的で呼び出している。  
こういうときは `forM_` とか使うんだっけ。  

書けた書けた。やったー！以下のように書いた。

```haskell
describe "binary operator" $ do
  it "accept all binary operators" $ do
    forM_ ["*", "a"] spec_binop
```

あと、先ほどの `(&)` のところは `\a b -> b a` に直した。

今のところ、選択肢が3つほどある。

* 文字列リテラルや数値リテラルのパーサを作る
* `if` や `for` などのパーサをつくる
* 優先順位の高い演算子 `++` などのパーサを作る

どれにしようかな。

訳がわからなくなってきた。  
前置インクリメントであったり、アドレス取得であったり、これらは他の演算子と記号が被っている。  
それが原因かはわからないけど、思い通りに動いてくれない。  

たとえば `1 && 2` という式があったときに、僕のパーサでは `1 & (&2)` と解釈してしまう。  
なぜこのように解釈してしまうか。  
二項演算子の `&` の優先順位は 11 、`&&` の優先順位は 14 、単項演算子の `&` は 3 である。  
というか、そもそも `&2` というのは間違っている。  
しかしだからといって、`&2` のような数字だけをパースしないようにしても、`a && b` などは  
引っかかってしまう。どうすればうまく実装できるだろう。  
まず、`a & (&b)` というのは存在しうるのか。  
`&b` というのは `b` のアドレスを取得するという意味であり、アドレスをビットの論理積に  
使うことなんて果たしてあるのか。ないだろう。  
よって `a & (&b)` という解釈の仕方はありえない。  
これは何が言えるかというと、`&` が2つ並んでいるとき、それは論理積以外にあり得ないということだ。  

Megaparsec というモジュールを使うことでデバッグが容易になるようだ。  
また今度使ってみる。  
チュートリアルは、[こちら](https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html)が良さそう。

`notFollowedBy` 便利。  
パースは成功させたいけど入力は消費したくない、というときに使える関数。  

式パーサがほぼ完成した！  
けっこう納得のいく出来。  
次はとうとうプリミティブ型のパーサを作っていく。  

issue というのをきちんと立ててからバグを直していくという方針のほうがいいかも。  
そちらのほうが現実で行われている開発に近い。  
次バグが見つかったときは、そのようにバグを直していくことにする。  

まずは整数型からいこう。  
最初は進数の変換を考えず、ただパースすることだけを考える。  
そのために、整数型の進数を保存しておく必要がある。  
これは型情報として保存しておこう。  

できた。Haskell で書いていると、どうしても共通部分を排除したくなる。  
ポイントフリースタイルを脳死で適用しているみたいな感じ。  
排除しすぎて逆にコードが難読化する感じがする。  
あんまりよくないかも。
