友達と Discord のサーバを建てた。  
名前とアイコン、活動内容などはまだ考え中。  
何か面白い変化があるといいな。

C++ パーサで詰まった部分がある。  
それは、演算子の優先順位と結合順序をどうするかという問題。  
具体的には、`1 + 2 + 3` という入力を与えたときは `((1 + 2) + 3)` と解析してほしいけど、  
`1 + 2 * 3` という入力を与えたときは `(1 + (2 * 3))` と解析してほしい。

* `1 + 2 + 3` : `((1 + 2) + 3)`
* `1 + 2 * 3` : `(1 + (2 * 3))`

解決策が思いついた。  
トップレベルに近いパーサは `+-` を読み込むパーサとし、  
トップレベルから遠いパーサは `*/` を読み込むパーサとする。
前者を `p_add_sub` として後者を `p_mul_div` とすると次のようになる。  
（`try` などは一旦考えない）

```haskell
p_add_sub = do
  lft <- p_mul_div
  op  <- oneOf "+-"
  rgt <- p_mul_div
  return (lft, op, rgt)

p_mul_div = do
  lft <- primitive
  op  <- oneOf "*/"
  rgt <- primitive
  return (lft, op, rgt)
```

こうすることで、`1 + 2 * 3` を与えたときは次の流れになる。  
と思って流れを書いていると間違いに気付いた。  
これでは不十分だ。  
`p_add_sub` はリスト的な何かを返さなければならない。  
それか木構造か。  
木構造のほうが難しそうだから、まずはリストを作ることにしよう。  
型はどんなふうにしようかな。  
`(Expression, [(String, Expression)]` にしよう。  
これであれば、`many` の戻り値をそのまま使うことができるから簡単だ。

ということで次のように書くことにした。

```haskell
p_add_sub_operator :: Parser String
p_add_sub_operator = string "+" <|> string "-"

p_mul_div_operator :: Parser String
p_mul_div_operator = string "*" <|> string "/"

p_add_sub :: Parser (Expression, [(String, Expression)])
p_add_sub = do
  lft <- p_mul_div
  rgt <- many $ p_add_sub_operator <*> p_mul_div
  return (lft, rgt)

p_mul_div :: Parser (Expression, [(String, Expression)])
p_mul_div = do
  lft <- p_primitive
  rgt <- many $ p_mul_div_operator <*> p_primitive
  return (lft, rgt)
```

ここで更にひとつ考えていなかったことがあった。  
`(Expression, [(String, Expression)])` というのもまた `Expresion` であるということだ。  
ということで、これを `data Expression` に追加して下記のように修正する。

```haskell
data Expression =
  ... |
  ExList (Expression, [(String, Expression)])
  deriving Show

...

p_add_sub :: Parser Expression
p_add_sub = do
  lft <- p_mul_div
  rgt <- many $ p_add_sub_operator <*> p_mul_div
  return . ExList $ (lft, rgt)

p_mul_div :: Parser Expression
p_mul_div = do
  lft <- p_primitive
  rgt <- many $ p_mul_div_operator <*> p_primitive
  return . ExList $ (lft, rgt)
```

これで完成だ（と思う）。  
具体的にシミュレーションしてみる。  

`1 + 2 * 3` という入力を与える。  
ここでは思考の単純化のために空白文字は考えない。  

`p_add_sub` のひとつめのパーサは `p_mul_div` なのでこのパーサに処理を託す。  
`p_mul_div` は `1` だけを読み取れ、それ以降の文字は読み取れない。  
なぜなら次の文字は `+` であり、これは `p_mul_div_operator` では読み取れないからだ。  
したがって、`p_mul_div` は `(1, [])` というパーサ結果をモナドに包んで返す。  
そしてこれの中身が呼び出し元の `p_add_sub` の `lft` に格納される。  

次に `p_add_sub_operator <*> p_mul_div` に一致するかどうかを判定する。  
次の文字は `+` であるため `p_add_sub_operator` によりこれを消費し、  
`2 * 3` が `p_mul_div` に渡される。  

`p_mul_div` のひとつ目のパーサである `p_primitive` は、`2` を読み取って `lft` に格納する。  
ふたつ目のパーサである `p_mul_div_operator <*> p_primitive` だが、  
これは成功する。なぜなら `* 3` の `*` は `p_mul_div_operator` が読み取り、  
`3` は `p_primitive` が読み取るからだ。  
こうして `p_mul_div_operator <*> p_primitive` は `("*", 3)` という結果になるため、  
これをリストにして `rgt` に格納する。  
`lft = 2` で `rgt = [("*", 3)]` だから、返される値は `ExList (2, [("*", 3)])` となる。  
これがモナドに包まれて呼び出し元に返される。

以上のような工程により、`p_add_sub_operator <*> p_mul_div` の  
結果は `ExList (2, [("*", 3)])` のようになる。  
これが `rgt` に格納されるため、  
最終的に作られる値は `ExList (1, ("+", [ExList (2, [("*", 3)]]))` となる。

できた。それでは実装していく。
