移動が必要だから4x4行列である必要がある？っぽい。3x3行列では移動が行えない。たぶんそんな感じ。

* 点の変換では、第四成分を1に設定したベクトルを使用する
* それに対して方向の変換では、第四成分を0に設定したベクトルを使用する
* もしくは4x4行列を3x3行列に縮小する
* 法線ベクトルの変換でも第四成分が0のベクトルを使用するが、変換方法が異なるらしい
* 4x4行列の4行目を変更する可能性があるのは`.perspective()`のみ

昨日Discordで質問したのだけど、ようやくその答えが見つかった。とりあえず、Discordでの報告の前に、今の理解を気ままにここに書いていこうと思う。

答えは既に知っている。以下のコードは、プロジェクション変換を正しく行うためだけに用意されたコードだ。

```javascript
let w = m[3] * x + m[7] * y + m[11] * z + m[15];
w = w || 1.0;
```

なんでもプロジェクション変換だけ他の変換と本質的に異なる部分があって、それは変換行列自体が変換対象の点の z 座標を必要とするところ。

比べる対象となる他の変換について理解する必要があるので説明すると、回転行列を作るために必要な情報は「回転軸」と「角度」だけ。拡大縮小行列を作るために必要な情報は「どれくらい拡大縮小するか」だけ。けど、プロジェクション変換行列には「視野角」や「アスペクト比」の他に「変換対象の点の z 座標」が必要。これはつまり、事前に変換行列が作れないことを意味する（変換対象の点の z 座標が与えられて初めて行列が完成する）。

GPU は事前に用意された行列でしか演算できない。しかしプロジェクション変換には z 座標が必要。この相反する2つの課題を、先人はひとつのルールを設けることで解決した。そのルールというのは「GPU は行列演算後の4次元ベクトルを第四成分で割る」である。

さっきは「プロジェクション変換には点の z 座標が必要」と書いた。具体的に z 座標をどのように使うかというと、点の正しい x と y を求める際に使用する。その求め方というのが「x と y をそれぞれ z で割る」という操作である。

この操作と先ほどのルールを合わせると、プロジェクション変換の際に使う行列に「z を第四成分の位置に移動させる操作」を持たせればいいことになる。以下のコードの `w` には、プロジェクション変換が行われない場合には `1.0` が、行われる場合には z が（厳密には -z が）入る。

```javascript
let w = m[3] * x + m[7] * y + m[11] * z + m[15];
w = w || 1.0;
```

そうして作られた `w` で、その後 x と y を割っている（z も割ってしまっているが、その前に「z を掛ける」みたいな操作を行っているので問題ない）。

```javascript
out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
return out;
```

結論としては、「なぜこのようにして第四成分を求めているか」の答えは「GPU でそのようなルールが設けられているから。glMatrix は GPU の動きを再現している」である。

昨日の日記に、ベクトルを使えばトーラスを簡単に実装できると書いた。今日は8分の1球体をベクトルを使って書いたんだけど、あまりにも簡単に書けたので驚いた。上が書き換え前のコードで、下が書き換え後のコード。

```javascript
for (let i = 0; i <= c; i++) {
  const langle = Math.PI / 180 * 90 / c * i;
  const rad = r * Math.sin(langle);
  const y = r * Math.cos(langle);
  for (let j = 0; j <= c; j++) {
    const sangle = Math.PI / 180 * 90 / c * j;
    const x = rad * Math.cos(sangle);
    const z = rad * Math.sin(sangle);
    data.push({ position: V3(x, y, z), color });
  }
}
```

```javascript
for (let i = 0; i <= c; i++) {
  const v = V3(r, 0, 0).rotate(V3(0, 0, 1), 90 / c * i);
  for (let j = 0; j <= c; j++) {
    const p = v.rotate(V3(0, 1, 0), -90 / c * j);
    data.push({ position: p, color });
  }
}
```

意味的にも理解しやすい。「ベクトル `(r, 0, 0)` を、z 軸を軸として何度か回転させ、それをまた y 軸を軸として何度か回転させる」とすんなり読める。

円を扱うときはベクトルの回転をうまく使うとよいことがわかった。この調子で他のコードも書き換えていく。

モデル変換行列と法線ベクトルがあるとき、モデル変換行列の逆行列の転置行列を使うことで法線ベクトルを変換できるとのこと。にわかには信じられない。なぜこのような操作で適切な変換が行えるのか。とりあえずこれが真だと仮定すると、次のコードはほぼ同じ値を出力する。

```javascript
const r = Mat4.rotate(V3(1, 0, 0), 33);
const m = Mat4.scale(1, 2, 3)
              .rotate(V3(1, 0, 0), 33)
              .translate(4, 5, 6);
const n = [7, 8, 9, 0];
const out = vec4.create();
vec4.transformMat4(out, n, r.primitive());
console.log(out);
vec4.transformMat4(out, n, m.invert().transpose().primitive());
console.log(out);
```

うーん、全然違う値を出力した。

勘違いしていることに気付いた。「拡大縮小変換により法線ベクトルの向きが変わることはない」と思っていた。これは間違いで、拡大縮小変換により法線ベクトルの向きが変わる場合がある。つまり僕が書いていたコードは間違っていた。ということで修正する。

年末の大掃除をした。コミットメッセージを「year-end cleaning」にした。ディレクトリ構成を大幅に変えた。

なかなかレイマーチングを勉強する気になれない。ずっとパソコンの前で別のことをしている。たとえば Discord をチェックしたり、自分のコミット内容をひたすら眺めていたり。自分の書いたコードを眺めるのがけっこう好き。眺めながら、よくここまで書いたなーと思ったりする。自分大好き人間。ただ、それだけだと満足できない。自分のコードを人に見てもらいたいし、凄いと言ってもらいたい。どうすれば自分のコードの凄さを人に知ってもらえるだろう。もしかすると井の中の蛙かもしれないけど、自分のコードはけっこう凄いと思う。四分木を書ける人ってこの世にどれくらいいるんだろう。1万人もいないんじゃないかな。いや、3Dの世界ではけっこう普通に使いそうだからもう少し多いか。式のメタファーを使って設計することは？これは流石に1万人もいないと思う。僕は式のメタファーを使ってうまく設計できる。 Polygonクラスの設計とか最高だと思うんだけど。式のメタファーではないけど、`.flatten()`の完成度とかめっちゃ高い。この関数が、ポリゴンをより組み立てやすくしてくれている。`.flatten()`がなければ、ポリゴンを組み立てたとしてもポリゴンの境界が目立ってしまう。`.flatten()`を使うことでポリゴンの境界を消してくれる。しかも頂点数も少なくしてくれる。

こういった色々なものを材料として自分にあった仕事を探し出せればいいのだけど…。

wgld.org の GLSL のチュートリアルを進めている。こちらのチュートリアルの内容は、doxas さんが Qiita にも投稿しておられる記事の内容に似ているので、以前その記事に沿って GLSL を触った僕としては復習のような感じで進めている。以前は GLSL を動かせる Web ページでチュートリアルを進めていたけど、今回は JavaScript から開発している。少しだけ成長を感じる。シェーダについてほぼ理解できているし、プログラムを簡単に書けるようにするためのライブラリの自作を終えている。非常に快適にチュートリアルを進めている。

ひとつ問題なのは、GLSL には変換行列のライブラリがないということだ。どうやってモデル変換とかビュー変換をするんだろう。といっても、これについてもある程度の知見は得られている。平行移動行列は3つの数字があれば簡単に構築できるし、回転行列は4つの数字があれば構築できる。一番複雑であろうプロテクション変換行列の作成についても、glMatrix の知見を深めたことでスムーズに構築できることだろう。こうして構築した行列と座標を使えば、…いや、そう単純な話ではない。どう単純じゃないかというと、GLSL はフラグメントシェーダに書くという点だ。GLSL では、与えられるのはピクセル座標と時間とマウス座標くらいで、それ以外の情報は与えられない。そういった制約の中で、「ピクセルに何色を描画するか」を決めなければならない。思っていたよりも、今まで学んできた3Dとは根本的に異なる。まあでもたぶんこれまでの知識は役立ってくると思う。

そういえば、GLSL だけで3Dを描画するのはまだ先だと書かれていったけど、もう既に3Dっぽい。中心に集まっては消えていくトーラスであったりオーブであったり。そして、既に平行移動とスケーリングは無意識に行っている。行列は使わずに。ただ、これらの無意識な行いには一貫性がなく、「この値を変えるとどうなるんだろう」とか、そういったことを考えながら行っている。行列を使えば、図形の移動や回転、スケーリングが直感的に行えるのに。やっぱり少し GLSL に不便さを感じる。レイトレーシングがこの問題を解決する銀の弾丸となればいいのだけど。

「様々な図形を描く」のチュートリアルを終えた。
