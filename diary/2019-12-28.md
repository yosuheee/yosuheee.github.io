式のメタファーを利用して、気軽にポリゴンを組み合わせられるようになっている。その気軽さを使って様々な基本図形を作っている。たとえば、正方形と円柱の胴部を4分の1にしたものと球体を8分割したものを組み合わせて角丸の立方体を作ったり。そういった、少し難しいけど基本図形を組み合わせて作れる図形を作ってみたり、それを回転させたりするのが楽しい。

しかし不満がある。回転させるときにGLSLを使っているのだけど、GLSLに設定するattribute変数やuniform変数の名前はModelクラスにハードコードされているのに、GLSLのソースコードは使用者側が用意する。つまり、GLSLのソースコードを書く開発者は、Modelクラスの仕様を理解していなければならない。この設計はまずい。Modelクラスの`draw()`を呼び出したときにattribute変数やuniform変数に何を設定するかは、Modelクラスか開発者のどちらか一方に寄せる必要がある。

どちらに寄せようか。使用者側に寄せると、使用者の負担が大きくなる。GLSLのソースコードを用意しなければならないし、attribute変数やuniform変数への設定も自分で行わなければならない。対してModelクラスに寄せると、使用者の負担は大幅に減るが、その分使用者側の自由度が下がる。これは個人開発ではあまりやりたくない。簡易性と柔軟性の両方を持ち合わせるのが理想。そんなことは果たして可能なのか。

Modelクラスには`.rotate()`があるが、これは`.matrix`と`.r_matrix`を変更した新しいModelを返す。そしてこの2つの値は、最終的にuniform変数の`matrix`と`r_matrix`に格納される。ここで少し発想が浮かんだ。Modelクラスの初期化時に、uniform変数の名前を設定できるようにできればいいのではないか。たとえば以下のように。

```javascript
po.model(gl, {
  m_matrix: "matrix",
  r_matrix: "r_matrix",
})
```

`Polygon.flatten()` を実装した。しかし、計算量が2乗なのが気になるところ…。八分木を使えばもっと速くなるのかな。

自分の書いたプログラムを誰かに見てほしいな。

八分木の設計をしよう。思ったけど、検索対象が点であれば、八分木を使う必要すらないかも。256x256x256の3次元配列を用意して、各要素に点の情報を格納する。そして、検索したい点があれば、その点の属する要素を計算で求めて調査する。確かにこれでいける。わざわざ八分木を使う必要はない。こういうアルゴリズムは何と呼ぶんだろう。

とりあえず方針は決まったので実装できる。3次元空間は、ポリゴンが納まるギリギリの立方体のほうがいい。ポリゴンの各頂点の位置一覧は`this.data.map(d => d.position)`で取り出せるから、あとはそこからxの最小と最大、yの最小と最大、zの最小と最大を取り出せばいい。定数倍は気にしない方向で実装すると、`const pos = this.data.map(d => d.position);`と`pos`定数を定義したとき、xの最小は`pos.reduce((a, c) => Math.min(a, c.x));`みたいにして求められる。この調子で各成分の最小と最大を取り出すコードは次のようになる。

```javascript
const pos = this.data.map(d => d.position);
const min = {
  x: pos.reduce((a, c) => Math.min(a, c.x)),
  y: pos.reduce((a, c) => Math.min(a, c.y)),
  z: pos.reduce((a, c) => Math.min(a, c.z)),
};
const max = {
  x: pos.reduce((a, c) => Math.max(a, c.x)) + 0.01,
  y: pos.reduce((a, c) => Math.max(a, c.y)) + 0.01,
  z: pos.reduce((a, c) => Math.max(a, c.z)) + 0.01,
};
```

そして新たに256x256x256の配列を作成する。

```javascript
const arr = range(256 * 256 * 256).map(_ => []);
```

更に、座標からインデックスを求める関数を定義する。

```javascript
const to_index = p => {
  const x = Math.floor(p.x / (max.x - min.x) * 256);
  const y = Math.floor(p.y / (max.y - min.y) * 256);
  const z = Math.floor(p.z / (max.z - min.z) * 256);
  return x * 256 * 256 + y * 256 + z;
};
```

このように関数を定義した後、`arr`に次々と点を入れていく。

```javascript
for (const p of pos) arr[to_index(p)].push(p);
```

あとは、各頂点について、マージする点かどうかを判定していく。これで計算量がだいぶ抑えられるはず。最悪計算量は同じになるので競プロとかでは使えないけど、今回のケースでは大丈夫。

とりあえず、上のコードをひとつにしたものも書いておく。

```javascript
const n = 8;

const pos = this.data.map(d => d.position);
const min = {
  x: pos.reduce((a, c) => Math.min(a, c.x)),
  y: pos.reduce((a, c) => Math.min(a, c.y)),
  z: pos.reduce((a, c) => Math.min(a, c.z)),
};
const max = {
  x: pos.reduce((a, c) => Math.max(a, c.x)) + 0.01,
  y: pos.reduce((a, c) => Math.max(a, c.y)) + 0.01,
  z: pos.reduce((a, c) => Math.max(a, c.z)) + 0.01,
};

const index = p => {
  const x = Math.floor(p.x / (max.x - min.x) * power(2, n));
  const y = Math.floor(p.y / (max.y - min.y) * power(2, n));
  const z = Math.floor(p.z / (max.z - min.z) * power(2, n));
  return x * power(4, n) + y * power(2, n) + z;
};

const arr = range(power(power(2, n), 3)).map(_ => []);
for (const p of pos) arr[index(p)].push(p);
```

書いていて思ったけど、別に2のべき乗にする必要がない。けど、将来的に八分木を実装することを意識していんだ！ということをアピールするために、あえて2のべき乗にしておく。

ここからすることは既存のコードと同じであるため省略。ということで実装しよう。

実装が終わった。体感速度がかなり短くなった。`flatten()` にかかる時間を計測しよう。おそらく驚くほど速くなっているはず。その前にいったんコミットしよう。
