式のメタファーを利用して、気軽にポリゴンを組み合わせられるようになっている。その気軽さを使って様々な基本図形を作っている。たとえば、正方形と円柱の胴部を4分の1にしたものと球体を8分割したものを組み合わせて角丸の立方体を作ったり。そういった、少し難しいけど基本図形を組み合わせて作れる図形を作ってみたり、それを回転させたりするのが楽しい。

しかし不満がある。回転させるときにGLSLを使っているのだけど、GLSLに設定するattribute変数やuniform変数の名前はModelクラスにハードコードされているのに、GLSLのソースコードは使用者側が用意する。つまり、GLSLのソースコードを書く開発者は、Modelクラスの仕様を理解していなければならない。この設計はまずい。Modelクラスの`draw()`を呼び出したときにattribute変数やuniform変数に何を設定するかは、Modelクラスか開発者のどちらか一方に寄せる必要がある。

どちらに寄せようか。使用者側に寄せると、使用者の負担が大きくなる。GLSLのソースコードを用意しなければならないし、attribute変数やuniform変数への設定も自分で行わなければならない。対してModelクラスに寄せると、使用者の負担は大幅に減るが、その分使用者側の自由度が下がる。これは個人開発ではあまりやりたくない。簡易性と柔軟性の両方を持ち合わせるのが理想。そんなことは果たして可能なのか。

Modelクラスには`.rotate()`があるが、これは`.matrix`と`.r_matrix`を変更した新しいModelを返す。そしてこの2つの値は、最終的にuniform変数の`matrix`と`r_matrix`に格納される。ここで少し発想が浮かんだ。Modelクラスの初期化時に、uniform変数の名前を設定できるようにできればいいのではないか。たとえば以下のように。

```javascript
po.model(gl, {
  m_matrix: "matrix",
  r_matrix: "r_matrix",
})
```

`Polygon.flatten()` を実装した。しかし、計算量が2乗なのが気になるところ…。八分木を使えばもっと速くなるのかな。

自分の書いたプログラムを誰かに見てほしいな。

八分木の設計をしよう。思ったけど、検索対象が点であれば、八分木を使う必要すらないかも。256x256x256の3次元配列を用意して、各要素に点の情報を格納する。そして、検索したい点があれば、その点の属する要素を計算で求めて調査する。確かにこれでいける。わざわざ八分木を使う必要はない。こういうアルゴリズムは何と呼ぶんだろう。

とりあえず方針は決まったので実装できる。3次元空間は、ポリゴンが納まるギリギリの立方体のほうがいい。ポリゴンの各頂点の位置一覧は`this.data.map(d => d.position)`で取り出せるから、あとはそこからxの最小と最大、yの最小と最大、zの最小と最大を取り出せばいい。定数倍は気にしない方向で実装すると、`const pos = this.data.map(d => d.position);`と`pos`定数を定義したとき、xの最小は`pos.reduce((a, c) => Math.min(a, c.x));`みたいにして求められる。この調子で各成分の最小と最大を取り出すコードは次のようになる。

```javascript
const pos = this.data.map(d => d.position);
const min = {
  x: pos.reduce((a, c) => Math.min(a, c.x)),
  y: pos.reduce((a, c) => Math.min(a, c.y)),
  z: pos.reduce((a, c) => Math.min(a, c.z)),
};
const max = {
  x: pos.reduce((a, c) => Math.max(a, c.x)) + 0.01,
  y: pos.reduce((a, c) => Math.max(a, c.y)) + 0.01,
  z: pos.reduce((a, c) => Math.max(a, c.z)) + 0.01,
};
```

そして新たに256x256x256の配列を作成する。

```javascript
const arr = range(256 * 256 * 256).map(_ => []);
```

更に、座標からインデックスを求める関数を定義する。

```javascript
const to_index = p => {
  const x = Math.floor(p.x / (max.x - min.x) * 256);
  const y = Math.floor(p.y / (max.y - min.y) * 256);
  const z = Math.floor(p.z / (max.z - min.z) * 256);
  return x * 256 * 256 + y * 256 + z;
};
```

このように関数を定義した後、`arr`に次々と点を入れていく。

```javascript
for (const p of pos) arr[to_index(p)].push(p);
```

あとは、各頂点について、マージする点かどうかを判定していく。これで計算量がだいぶ抑えられるはず。最悪計算量は同じになるので競プロとかでは使えないけど、今回のケースでは大丈夫。

とりあえず、上のコードをひとつにしたものも書いておく。

```javascript
const n = 8;

const pos = this.data.map(d => d.position);
const min = {
  x: pos.reduce((a, c) => Math.min(a, c.x)),
  y: pos.reduce((a, c) => Math.min(a, c.y)),
  z: pos.reduce((a, c) => Math.min(a, c.z)),
};
const max = {
  x: pos.reduce((a, c) => Math.max(a, c.x)) + 0.01,
  y: pos.reduce((a, c) => Math.max(a, c.y)) + 0.01,
  z: pos.reduce((a, c) => Math.max(a, c.z)) + 0.01,
};

const index = p => {
  const x = Math.floor(p.x / (max.x - min.x) * power(2, n));
  const y = Math.floor(p.y / (max.y - min.y) * power(2, n));
  const z = Math.floor(p.z / (max.z - min.z) * power(2, n));
  return x * power(4, n) + y * power(2, n) + z;
};

const arr = range(power(power(2, n), 3)).map(_ => []);
for (const p of pos) arr[index(p)].push(p);
```

書いていて思ったけど、別に2のべき乗にする必要がない。けど、将来的に八分木を実装することを意識していることをアピールするために、あえて2のべき乗にしておく。

この後のコードは既存のコードと同じであるため省略。ということで実装しよう。

実装が終わった。体感速度がかなり短くなった。`flatten()` にかかる時間を計測しよう。おそらく驚くほど速くなっているはず。その前にいったんコミットしよう。

`sphere(0.8, [0.6, 0.6, 0.6], 32, 32).flatten();` にかかる時間を計測する。改善前が6500ms、改善後が100ms。ということで65倍速くなった。次は`32`を`40`にして計測してみよう。改善前が15000ms、改善後が160ms。およそ100倍近く早くなっている。まさかここまで高速化するとは思わなかった。満足のいく結果が得られた。これで、とりあえずは`Polygon.flatten()`について考える必要はなくなりそうだ。

ひとつ懸念点があるとすれば、近い条件を満たしていても、たまに「近くない」と判定されてしまうこと。しかし、その可能性は非常に低い上に、近くないと判定されても特に問題がない。だから、とりあえずスルーしておく。

`flatten()`で定義されている定数のスコープが少し広いので、狭めるためにクロージャを利用する。ということで、`min`と`max`だけスコープを狭められた。他の定数のスコープも狭めたいけど、うまくいきそうにないので断念。

JavaScriptを触っていると、たまにものすごく型が欲しくなる。けれどそこは我慢。TypeScriptを入れようか悩んだりもするけど、ちょっと入れるのが怖い。TypeScriptを入れてしまうと、他にも色々と付随したものを入れなくちゃならなくなりそうで怖い。全体を把握しきれなくなる。とりあえずJavaScriptで頑張っていく。JavaScript好きだし。最近ものすごく書きやすくなってきている。JavaScriptは嫌われがちで見下されがちだけど、僕は変わらず好きで居続けよう。

今まで日記の口調が安定しなかったけど、この口調だと書きやすいかも。「かも」とか「みたいな」とか「とか」とか「けど」とか、そういうゆるい言葉を使うと話しやすい。たぶん争いがあんまり好きじゃないんだと思う。やんわり言っておけば争いが起こることは少ないから、ゆるい言葉を好んでよく使う。だから、厳密性の求められるような文章を書かないといけない状況になると、途端に文章が書けなくなるんだと思う。

いやー、本当にこの口調だと書きやすい。年末にこの事実に気付くことができてよかった。来年はこの口調で毎日日記を書いていこう。毎日何かを書くことで何か発見があるかも。文章を書くと孤独感も少し和らぐ気がする。たまに、この世で嫌われているのは僕だけなんじゃないかという錯覚に陥る。みんなは普通に人と話しているように見えるのに、僕だけ人とうまくコミュニケーションを取れないように錯覚する。けど、ここにアウトプットすることで、そういった不安も多少なくなってくれる。

wgld.orgチュートリアルを進めていこう。

前回は「反射光によるライティング」を終えた。法線ベクトル、光方向ベクトル、視線ベクトルについて理解した。反射光を実装する際は、光方向ベクトルと視線ベクトルを足して正規化したベクトルを使うことになる。足す前に、各ベクトルを正規化しておくのを忘れないように。でないとおかしくなる。

今回は「フォンシェーディング」をやる。…と言いたいところだけど、そういえばトーラスを実装したいんだった。なぜチュートリアルでトーラスを使うかがわからなかったけど、今日考えていてようやく気付いた。球体だと回転させても変化がないし、立方体だと曲線がないので面白くない。トーラスはこの2つの欠点を補う図形である。だからチュートリアルで使われてるんじゃないかと思う。たまに僕もトーラスが欲しくなるので、今から実装することにする。
